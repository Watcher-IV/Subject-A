<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>+Frequência+</title>

  <!-- Fonts (títulos + mono legível) -->
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --black:#000000;
      --paper:#e8e8e8;
      --muted:#bdbdbd;
      --accent:#9b30ff;
      --card-border: rgba(230,230,230,0.06);

      --container-w: 640px;
      --base-font-size: 16px;

      --grain-opacity: 0.09;
      --noise-opacity: 0.12;
      --scanline-opacity: 0.06;
    }

    /* Reset & base */
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--black);
      color:var(--paper);
      font-family: 'IBM Plex Mono', monospace;
      font-size:var(--base-font-size);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:auto;
    }

    /* center container */
    .wrap{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
    }

    .card{
      width:100%;
      max-width:var(--container-w);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid var(--card-border);
      box-shadow: 0 12px 40px rgba(0,0,0,0.6);
      padding:28px 28px 32px 28px;
      position:relative;
      overflow:visible;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      image-rendering: pixelated;
    }

    /* header / legend */
    .legend{
      font-size:0.875rem; /* 14px */
      color:var(--muted);
      margin-bottom:12px;
      font-family: 'IBM Plex Mono', monospace;
      text-transform:none;
      letter-spacing:0.06em;
    }

    h1{
      font-family: 'Playfair Display', serif;
      font-size:1.95rem; /* ~31px */
      margin:0;
      color:var(--paper);
      letter-spacing:0.02em;
      margin-bottom:6px;
      text-transform:uppercase;
    }
    h2{
      font-family: 'IBM Plex Mono', monospace;
      font-size:0.95rem;
      color:var(--muted);
      margin:0 0 18px 0;
      font-weight:400;
      letter-spacing:0.04em;
    }

    /* frequency area */
    .freq-wrap{display:flex;justify-content:center;width:100%; margin-bottom:10px}
    .freq-box{
      background:transparent;
      color:var(--paper);
      width:260px;height:56px;
      border-radius:6px;
      padding:6px 10px;
      display:flex;align-items:center;justify-content:center;
      box-shadow: inset 0 -6px 18px rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.04);
      backdrop-filter: blur(2px);
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .freq-box:active, .freq-box:focus-within{ transform: translateY(1px); box-shadow: inset 0 -8px 20px rgba(0,0,0,0.55) }

    .freq-box input{
      width:100%;border:0;background:transparent;
      font-size:1.3rem; /* ~20.8px */
      font-weight:700;
      font-family: 'IBM Plex Mono', monospace;
      letter-spacing:2px;
      outline:none;color:var(--accent);
      text-shadow:0 0 6px rgba(155,48,255,0.10);
      caret-color:var(--paper);
      text-align:center;
      padding:4px 2px;
    }

    /* transcription / text block */
    .transcription{
      margin-top:16px;
      padding:16px;
      background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
      border-top:1px dashed rgba(255,255,255,0.02);
      max-height:58vh;
      overflow:auto;
      display:none;
      font-size:0.98rem; /* ~15.7px */
      line-height:1.62;
      color:var(--paper);
      width:100%;
      border-radius:4px;
    }
    .transcription.show{display:block}

    .typed-line{
      white-space:pre-wrap;
      font-family:'IBM Plex Mono', monospace;
      margin:8px 0;
    }

    /* overlay layers: grain + noise + scanlines (use absolute to sit on top of background but behind content) */
    .overlay{
      pointer-events:none;
      position:fixed;
      inset:0;
      z-index:1;
      image-rendering: pixelated;
    }
    /* both overlays sit below card content but above page background */
    .grain{
      mix-blend-mode:screen; /* light grain on dark bg */
      opacity:var(--grain-opacity);
      background-repeat:repeat;
      background-position:0 0;
      z-index:1;
    }
    .noise{
      mix-blend-mode:overlay;
      opacity:var(--noise-opacity);
      background-repeat:repeat;
      background-position: center;
      z-index:2;
    }
    .scan{
      pointer-events:none;
      position:fixed;
      inset:0;
      z-index:3;
      background-image: repeating-linear-gradient(180deg,
        rgba(255,255,255,var(--scanline-opacity)) 0px,
        rgba(255,255,255,var(--scanline-opacity)) 1px,
        rgba(255,255,255,0) 1px,
        rgba(255,255,255,0) 3px
      );
      background-size: 100% 3px;
      mix-blend-mode: multiply;
      opacity:0.6;
      animation:scanFlicker 3s linear infinite;
    }

    @keyframes scanFlicker{
      0%{opacity:0.50}
      25%{opacity:0.62}
      50%{opacity:0.42}
      75%{opacity:0.66}
      100%{opacity:0.50}
    }

    /* subtle glitch text effect when typing (kept simple) */
    .glitch-text{position:relative; display:inline-block}
    .glitch-text::before, .glitch-text::after{
      content:attr(data-text);
      position:absolute;left:0;top:0;width:100%;overflow:hidden;opacity:0.85;
      clip-path:polygon(0 0,100% 0,100% 50%,0 50%);
      pointer-events:none;
    }
    .glitch-text::before{transform:translate(1px,-1px);filter:blur(0.3px);color:var(--accent);opacity:0.9}
    .glitch-text::after{transform:translate(-1px,1px);filter:blur(0.6px);opacity:0.8}

    /* nicer internal scroll */
    .transcription::-webkit-scrollbar{height:8px;width:8px}
    .transcription::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.06);border-radius:6px}

    /* responsive */
    @media (max-width:640px){
      :root{ --container-w:92vw; --base-font-size:15px; }
      .freq-box{ width:86%; height:52px }
      .freq-box input{ font-size:1.1rem }
      h1{ font-size:1.45rem }
    }
  </style>
</head>
<body>
  <!-- overlays (we keep these in DOM so we can replace background-image dynamically if needed) -->
  <div class="overlay grain" id="overlay-grain" aria-hidden="true" style="background-image:url('images/grain.png');"></div>
  <div class="overlay noise" id="overlay-noise" aria-hidden="true" style="background-image:url('images/noise.png');"></div>
  <div class="scan" id="overlay-scan" aria-hidden="true"></div>

  <div class="wrap">
    <div class="card" id="card" role="main" aria-labelledby="pageTitle">
      <div>
        <div class="legend">Freq.Shifting - Insert the Frequence</div>
        
      </div>

      <div class="freq-wrap" style="margin-top:8px;">
        <div class="freq-box" role="group" aria-label="Frequência">
          <input id="freqInput" type="text" inputmode="numeric" autocomplete="off" maxlength="7" placeholder="---.---" aria-label="Frequência" />
        </div>
      </div>

      <div class="transcription" id="transcription" aria-live="polite"></div>
    </div>
  </div>

  <!-- audio elements (mantive os IDs originais) -->
  <audio id="ambient" loop preload="auto" src="audio/ambient_loop.mp3"></audio>
  <audio id="success" preload="auto" src="audio/success.mp3"></audio>
  <audio id="wrong1" preload="auto" src="audio/wrong1.mp3"></audio>
  <audio id="wrong2" preload="auto" src="audio/wrong2.mp3"></audio>
  <audio id="wrong3" preload="auto" src="audio/wrong3.mp3"></audio>

  <script>
    (function(){
      const TARGET = '136.555';
      const input = document.getElementById('freqInput');
      const ambient = document.getElementById('ambient');
      const success = document.getElementById('success');
      const wrongPool = [document.getElementById('wrong1'), document.getElementById('wrong2'), document.getElementById('wrong3')];
      const transcriptionEl = document.getElementById('transcription');
      const card = document.getElementById('card');
      let ambientStarted = false;

      /* ---------- format helpers ---------- */
      function formatFreq(raw){
        const digits = (raw || '').replace(/\D/g,'').slice(0,6);
        if(digits.length<=3) return digits;
        return digits.slice(0,3) + '.' + digits.slice(3);
      }

      function startAmbientIfNeeded(){
        if(ambientStarted) return;
        try{ ambient.volume = 0.12; ambient.play(); ambientStarted=true; }catch(e){}
      }

      /* ---------- input behaviour ---------- */
      input.addEventListener('keydown', e=>{ if(e.key===' '){ e.preventDefault(); } });
      input.addEventListener('input', ()=>{ 
        const formatted = formatFreq(input.value);
        input.value = formatted;
        input.setAttribute('data-text', formatted);
        input.classList.add('glitch-text');
      });
      input.addEventListener('focus', ()=> startAmbientIfNeeded());
      input.addEventListener('keyup', e=>{ if(e.key==='Enter') submit(); });
      input.addEventListener('paste', e=>{
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData('text');
        const formatted = formatFreq(text);
        input.value = formatted;
      });

      /* ---------- submit logic ---------- */
      function submit(){
        const val = (input.value || '').trim();
        startAmbientIfNeeded();
        if(val === TARGET){
          try{ success.volume = 0.16; success.currentTime = 0; success.play(); }catch(e){}
          revealTranscription();
        } else {
          const r = Math.floor(Math.random()*wrongPool.length);
          const audio = wrongPool[r];
          if(audio){ try{ audio.currentTime=0; audio.volume=0.22; audio.play(); }catch(e){} }
          card.classList.add('glitch');
          setTimeout(()=> card.classList.remove('glitch'),520);
          try{ ambient.pause(); ambient.currentTime=0; }catch(e){}
          setTimeout(()=>{ location.reload(); }, 3000);
        }
      }

      /* ---------- typing reveal ---------- */
      function revealTranscription(){
        try{ ambient.volume = 0.02; setTimeout(()=>ambient.pause(),1600); }catch(e){}
        const lines = [
          "teste teste teste",
          "teste2 teste2 teste2",
          "Alguém costurou um nome dentro do microfone e nunca mais tirou.",
          "Choveubaixo do telhado: metal derretido em forma de lágrima; havia rótulos em língua de inseto.",
          "A criança aprendeu a cantar com os pregos e agora quer que você cante também.",
          "Há um espelho que esqueceu como refletir — ele mastiga promessas e as devolve como moeda.",
          "Não é memória. É um recado rasgado em pele falsa: segure a respiração e ouça o piso resolver seu nome.",
          "O que você chamou de silêncio estava apenas adormecido com fome. Não acorde o que já tem dentes.",
          "Se tentou catalogar os sons, saiba: as palavras se dobram em argila e fazem uma escada para o porão.",
          "Fique. Não fique. É indiferente. As portas contaram a piada antes de perceberem que não havia plateia.",
          "— nada aqui pede licença. aceita o erro; ele é um convite com sobra de sangue."
        ];

        transcriptionEl.innerHTML = '';
        transcriptionEl.classList.add('show');

        let lineIndex = 0;
        function typeLine(){
          if(lineIndex >= lines.length) return;
          const txt = lines[lineIndex];
          const lineEl = document.createElement('div');
          lineEl.className = 'typed-line';
          transcriptionEl.appendChild(lineEl);

          let i = 0;
          const baseDelay = 28;
          const jitter = 12;
          function typeChar(){
            if(i <= txt.length){
              lineEl.textContent = txt.slice(0, i);
              transcriptionEl.scrollTop = transcriptionEl.scrollHeight;
              i++;
              setTimeout(typeChar, baseDelay + Math.floor(Math.random()*jitter));
            } else {
              lineIndex++;
              setTimeout(typeLine, 420);
            }
          }
          typeChar();
        }
        typeLine();
      }

      /* ---------- initial focus ---------- */
      input.focus();

      /* ---------- grain/noise image check + canvas fallback ---------- */
      (function ensureOverlays(){
        const grainEl = document.getElementById('overlay-grain');
        const noiseEl = document.getElementById('overlay-noise');
        const grainPath = grainEl.getAttribute('style')?.match(/url\(['"]?([^'")]+)['"]?\)/)?.[1] || 'images/grain.png';
        const noisePath = noiseEl.getAttribute('style')?.match(/url\(['"]?([^'")]+)['"]?\)/)?.[1] || 'images/noise.png';

        function testImage(path){ 
          return new Promise(res=>{
            const img = new Image();
            img.onload = ()=> res(true);
            img.onerror = ()=> res(false);
            // bust cache for debug
            img.src = path + '?_v=' + (new Date()).getTime();
          });
        }

        async function run(){
          const gOk = await testImage(grainPath).catch(()=>false);
          const nOk = await testImage(noisePath).catch(()=>false);

          if(!gOk || !nOk){
            console.warn('[overlay] grain or noise failed to load. Using canvas fallback.');
            // create a small tile for grain
            const c = document.createElement('canvas');
            c.width = 256; c.height = 256;
            const ctx = c.getContext('2d');
            const imgd = ctx.createImageData(c.width, c.height);
            for(let i=0;i<imgd.data.length;i+=4){
              const v = Math.random()*255|0;
              imgd.data[i] = v; imgd.data[i+1] = v; imgd.data[i+2] = v;
              imgd.data[i+3] = Math.random()*40|0; // slight transparency
            }
            ctx.putImageData(imgd,0,0);
            const dataUrl = c.toDataURL('image/png');

            // apply to grainEl
            if(grainEl) {
              grainEl.style.backgroundImage = `url('${dataUrl}')`;
              grainEl.style.mixBlendMode = 'screen';
              grainEl.style.opacity = '0.12';
            }

            // noise fallback: use a larger canvas with stronger noise
            const c2 = document.createElement('canvas');
            c2.width = 512; c2.height = 256;
            const ctx2 = c2.getContext('2d');
            const id2 = ctx2.createImageData(c2.width,c2.height);
            for(let i=0;i<id2.data.length;i+=4){
              const v = Math.random()*255|0;
              id2.data[i] = v; id2.data[i+1] = v; id2.data[i+2] = v;
              id2.data[i+3] = Math.random()*80|0;
            }
            ctx2.putImageData(id2,0,0);
            const dataUrl2 = c2.toDataURL('image/png');
            if(noiseEl){
              noiseEl.style.backgroundImage = `url('${dataUrl2}')`;
              noiseEl.style.mixBlendMode = 'overlay';
              noiseEl.style.opacity = '0.14';
            }
          } else {
            // if both ok, ensure opacities suitable
            if(grainEl) grainEl.style.opacity = '0.09';
            if(noiseEl) noiseEl.style.opacity = '0.12';
          }
        }

        run();
      })();

      /* Optional: small UX: press Enter on body to submit when input focused */
      document.addEventListener('keydown', e=>{
        if(e.key === 'Enter' && document.activeElement === input){
          submit();
        }
      });

    })();
  </script>
</body>
</html>